import os
import yara
import requests

class yara_setup(object):
    def __init__(self):
        # Defined filepaths
        pwd = os.getcwd()
        self.rules = []

        if pwd.endswith("verification"):
            self.rulepath = "%s/rules" % pwd
            self.malware_location = "%s/malware_samples" % pwd
        else:
            self.rulepath = "%s/verification/rules" % pwd
            self.malware_location = "%s/verification/malware_samples" % pwd

        yarfiles = self.get_yara_files(self.rulepath)

        # FAST - less rules
        #compiled_rules = self.compile_rules(yarfiles)

        # SLOW - many rules
        rulepaths = self.get_all_rule_paths(yarfiles)
        compiled_rules = self.compile_rules(rulepaths)

    # Returns list of all yar files in root folder 
    def get_yara_files(self, filepath):
        return [item for item in os.listdir(filepath) if item.endswith(".yar")]

    # Compiles rules based on self.rules list
    def compile_rules(self, rulepaths):
        for item in rulepaths:
            path = "%s/%s" % (self.rulepath, item)
            # Might be bad practice as it fucks up. Compile individual rules instead 
            try:
                self.rules.append(yara.compile(path, error_on_warning=False))
            except yara.SyntaxError as e:
                continue

    # Generates dictionary with counter of items
    def generate_dictionary(self, findings, rule_matches):
        full_dict = {}
        full_dict["rule_counter"] = rule_matches
        for item in findings:
            item = str(item)
            exists_check = False

            for key, value in full_dict.iteritems():
                if item == key:
                    full_dict[key] += 1
                    exists_check = True
                    break

            if not exists_check:
                full_dict[item] = 1

        return full_dict

    # Analyzes a file and returns dictionary
    def analyze_file(self, filepath):
        tot_matches = []
        match_counter = 0
        for rule in self.rules:
            matches = rule.match(filepath)
            if matches:
                match_counter += 1
                tot_matches.extend(matches)

        # Generate dict here
        return self.generate_dictionary(tot_matches, match_counter)

    # Downloads file before analyzing it
    def analyze_url(self, url):
        filepath = self.get_file_from_url(url)
        if "error" in filepath:
            return filepath 

        ret = self.analyze_file(filepath) 
        ret["filename"] = filepath
        return ret

    # Overwrites instead of checking.
    def get_file_from_url(self, url):
        local_filename = "%s/%s" % (self.malware_location, url.split('/')[-1])

        if len(local_filename) > 256:
            local_filename = "%s/%s" % (self.malware_location, url.split('/')[:-255])

        # Not really sure how this will work :o
        if not os.path.exists(self.malware_location):
            os.mkdir(self.malware_location)

        # Make it non-generic?
        try:
            reply = requests.get(url, stream=True)
        except:
            return {"error": "invalid request for url %s" % url}

        with open(local_filename, 'wb') as tmp:
            for chunk in reply.iter_content(chunk_size=1024):
                if chunk:
                   tmp.write(chunk) 

        return local_filename

    # Returns list of all yara includes in file
    # Hardcoded for paths in https://github.com/Yara-Rules/rules
    def find_includes(self, filename):
        with open("%s/%s" % (self.rulepath, filename), "r") as tmp:
            return [line[11:-2] for line in tmp.readlines() if line.startswith("include")]

    # Gets all rules available from root folder
    def get_all_rule_paths(self, yar_array):
        all_filepaths = []
        for item in yar_array:
            all_filepaths.extend(self.find_includes(item))

        return all_filepaths

if __name__ == "__main__":
    setup = yara_setup()
    data = setup.analyze_url("http://172.28.3.186:8000/Password-Sentinel-setup.exe")
    print "\n"
    print data
